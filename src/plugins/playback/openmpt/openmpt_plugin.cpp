#include <HippoMessages.h>
#include <HippoPlugin.h>
#include <HippoSettings.h>
#include <libopenmpt/libopenmpt.h>
#include <libopenmpt/libopenmpt.hpp>

#include <assert.h>
#include <string.h>
#include <sstream>
#include <string>
#include <vector>

const int MAX_EXT_COUNT = 16 * 1024;
static char s_supported_extensions[MAX_EXT_COUNT];
const char* PLUGIN_NAME = "openmpt";

const HippoIoAPI* g_io_api = nullptr;
const HippoSettingsAPI* g_settings_api = nullptr;
HippoLogAPI* g_hp_log = nullptr;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define ID_SAMPLE_RATE "SampleRate"
#define ID_CHANNELS "Channels"
#define ID_MASTER_GAIN "MasterGain"
#define ID_STEREO_SEPARATION "StereoSeparation"
#define ID_VOLUME_RAMPING "VolumeRamping"
#define ID_INTERPOLATION_RANGE "InterploationRange"
#define ID_TEMPO_FACTOR "TempoFactor"
#define ID_PITCH_FACTOR "PitchFactor"
#define ID_USE_AMIGA_RESAMPLER_AMIGA_MODS "AmigaModResampling"
#define ID_AMIGA_RESAMPLER_FILTER "AmigaModResamplerFilter"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// clang-format off

static const HSIntegerRangeValue s_interpolation_filter_ranges[] = {
    {"Default", 0},
    {"No Interpolation (zero order hold)", 1},
    {"Linear Interpolation", 2},
    {"Cubic Interpolation", 4},
    {"Windowed sinc with 8 taps", 8},
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const HSIntegerRangeValue s_volume_ramping_range[] = {
    {"Default", -1},
    {"Off", 0},
    {"1 ms", 1},
    {"2 ms", 2},
    {"3 ms", 3},
    {"5 ms", 5},
    {"10 ms", 10},
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const HSIntegerRangeValue s_sample_rate[] = {
    {"Default", 0},
    {"6000", 6000},
    {"8000", 6000},
    {"11025", 11025},
    {"22050", 22050},
    {"32000", 32000},
    {"44100", 44100},
    {"48000", 48000},
    {"82000", 82000},
    {"96000", 96000},
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const HSIntegerRangeValue s_channels[] = {
    {"Default", 0},
    {"Mono", 1},
    {"Stereo", 2},
    {"Quad", 3},
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const HSStringRangeValue s_amiga_filter_values[] = {
    {"Default filter", "auto"},
    {"Amiga A500 filter", "a500"},
    {"Amiga A1200 filter", "a1200"},
    {"Unfilterned", "unfiltered"},
};

// clang-format on
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

static HSSetting s_settings[] = {
    HSBoolValue(ID_USE_AMIGA_RESAMPLER_AMIGA_MODS, "Use Amiga Resampler for Amiga modules",
                "Set to enable the Amiga resampler for Amiga modules. This emulates the sound characteristics of "
                "the Paula chip and overrides the selected interpolation filter. Non-Amiga module formats are not "
                "affected by this setting.",
                false),
    HSStringValue_DescRange(ID_AMIGA_RESAMPLER_FILTER, "Filter type for Amiga Resampler",
                            "Filter type for Amiga filter if enabled", "auto", s_amiga_filter_values),
    HSIntValue_DescRange(ID_SAMPLE_RATE, "Sample rate",
                         "Default (recommended) uses the sample rate by the output device", 0, s_sample_rate),
    HSIntValue_DescRange(ID_CHANNELS, "Channels",
                         "Default (recommended) uses the number of channels the current song has.", 0, s_channels),
    HSFloatValue_Range(ID_MASTER_GAIN, "Master Gain",
                       "The related value represents a relative gain in decibel. The default value is 0", 0, -12, 12),
    HSIntValue_Range(ID_STEREO_SEPARATION, "Stereo Separation",
                     "The related value represents the stereo separation generated by the libopenmpt mixer in "
                     "percent. The default value is 100 and supported range is 0 - 200",
                     100, 0, 200),
    HSIntValue_DescRange(ID_VOLUME_RAMPING, "Volume Ramping Strength",
                         "Off completely disables volume ramping. This might cause clicks in sound output. Higher "
                         "values imply slower/softer volume ramps.",
                         0, s_volume_ramping_range),
    HSIntValue_DescRange(ID_INTERPOLATION_RANGE, "Interpolation Filter",
                         "The related value represents the interpolation filter length used by the libopenmpt mixer.",
                         0, s_interpolation_filter_ranges),
    HSFloatValue_Range(ID_TEMPO_FACTOR, "Tempo Factor", "Set the tempo factor. Default value is 1.0", 1.0, 0.0, 2.0f),
    HSFloatValue_Range(ID_PITCH_FACTOR, "Pitch Factor", "Set the pitch factor. Default value is 1.0", 1.0, 0.0, 2.0f),
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

enum class Channels {
    Default,
    Mono,
    Stereo,
    Quad,
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct OpenMptData {
    openmpt::module* mod = 0;
    const HippoMessageAPI* message_api;
    std::string ext;
    // number of channels to render
    Channels channels;
    int sample_rate;
    float length = 0.0f;
    void* song_data = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const char* openmpt_supported_extensions() {
    // If we have already populated this we can just return

    if (s_supported_extensions[0] != 0) {
        return s_supported_extensions;
    }

    std::vector<std::string> ext_list = openmpt::get_supported_extensions();
    size_t count = ext_list.size();

    for (size_t i = 0; i < count; ++i) {
        strcat(s_supported_extensions, ext_list[i].c_str());
        if (i != count - 1) {
            strcat(s_supported_extensions, ",");
        }
    }

    return s_supported_extensions;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void* openmpt_create(const HippoServiceAPI* service_api) {
    OpenMptData* user_data = new OpenMptData;

    g_io_api = HippoServiceAPI_get_io_api(service_api, 1);
    user_data->message_api = HippoServiceAPI_get_message_api(service_api, 1);

    return (void*)user_data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int openmpt_destroy(void* user_data) {
    OpenMptData* data = (OpenMptData*)user_data;
    delete data;
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static HippoProbeResult openmpt_probe_can_play(const uint8_t* data, uint32_t data_size, const char* filename,
                                               uint64_t total_size) {
    int res = openmpt::probe_file_header(openmpt::probe_file_header_flags_default, data, data_size, total_size);

    switch (res) {
        case openmpt::probe_file_header_result_success: {
            hp_info("Supported: %s", filename);
            return HippoProbeResult_Supported;
        }
        case openmpt::probe_file_header_result_failure: {
            hp_debug("Unsupported: %s", filename);
            return HippoProbeResult_Unsupported;
        }

        case openmpt::probe_file_header_result_wantmoredata: {
            hp_warn("openmpt: Unable to probe because not enough data\n");
            break;
        }
    }

    hp_warn("openmpt: case %d not handled in switch. Assuming unsupported file\n", res);

    return HippoProbeResult_Unsupported;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if 0
static void send_pattern_data(struct OpenMptData* replayer_data) {
    flatbuffers::FlatBufferBuilder builder(16 * 1024);

    const int current_pattern = replayer_data->mod->get_current_pattern();
    const int current_row = replayer_data->mod->get_current_row();
    const int channel_count = replayer_data->mod->get_num_channels();
    const int num_rows = replayer_data->mod->get_pattern_num_rows(current_pattern);

    assert(channel_count < 2048);
    assert(num_rows < 512);

    flatbuffers::Offset<HippoTrackerChannel> channels[2048];

	for (int channel = 0; channel < channel_count; ++channel) {
        flatbuffers::Offset<HippoRowData> rows[512];

        for (int row = 0; row < num_rows; ++row) {
	        std::string note = replayer_data->mod->format_pattern_row_channel_command(current_pattern, row, channel, openmpt::module::command_note);
	        std::string instrument = replayer_data->mod->format_pattern_row_channel_command(current_pattern, row, channel, openmpt::module::command_instrument);
	        std::string effect = replayer_data->mod->format_pattern_row_channel_command(current_pattern, row, channel, openmpt::module::command_effect);
	        std::string vol_effect = replayer_data->mod->format_pattern_row_channel_command(current_pattern, row, channel, openmpt::module::command_parameter);

            auto note_name = builder.CreateString(note.c_str());
            auto inst_name = builder.CreateString(instrument.c_str());
            auto effect_name = builder.CreateString(effect.c_str());
            auto voleffect_name = builder.CreateString(vol_effect.c_str());

            HippoRowDataBuilder row_builder(builder);
            row_builder.add_note(note_name);
            row_builder.add_instrument(inst_name);
            row_builder.add_effect(effect_name);
            row_builder.add_volumeffect(voleffect_name);
	        rows[row] = row_builder.Finish();
        }

        auto row_data = builder.CreateVector(rows, num_rows);
        channels[channel] = CreateHippoTrackerChannel(builder, row_data);
	}

	auto channel_data = builder.CreateVector(channels, channel_count);
    auto tracker_data = CreateHippoTrackerData(builder, HippoTrackerType_Regular, current_pattern, current_row, channel_data);

    builder.Finish(CreateHippoMessageDirect(builder, MessageType_tracker_data, tracker_data.Union()));

    HippoMessageAPI_send(replayer_data->message_api, builder.GetBufferPointer(), builder.GetSize());

    /*
	for (int i = 0; i < 64; ++i) {
	    std::string t = replayer_data->mod->highlight_pattern_row_channel(pattern, i, 0);
	    std::string note = replayer_data->mod->format_pattern_row_channel_command(pattern, i, 0, openmpt::module::command_note);
	    printf("%04x %s - %s\n", i, t.c_str(), note.c_str());
	}
	*/
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void settings_apply(OpenMptData* data, const HippoSettingsAPI* api) {
    int int_value = 0;
    float float_value = 0;
    char* str = nullptr;
    bool bool_value = false;
    const char* ext = data->ext.c_str();

    if (HippoSettings_get_int(api, ext, ID_SAMPLE_RATE, &int_value) == HippoSettingsError_Ok) {
        data->sample_rate = int_value;
    }

    if (HippoSettings_get_int(api, ext, ID_CHANNELS, &int_value) == HippoSettingsError_Ok) {
        data->channels = (Channels)int_value;
    }

    if (HippoSettings_get_float(api, ext, ID_MASTER_GAIN, &float_value) == HippoSettingsError_Ok) {
        data->mod->set_render_param(openmpt::module::RENDER_MASTERGAIN_MILLIBEL, int(float_value * 1000));
    }

    if (HippoSettings_get_int(api, ext, ID_STEREO_SEPARATION, &int_value) == HippoSettingsError_Ok) {
        data->mod->set_render_param(openmpt::module::RENDER_STEREOSEPARATION_PERCENT, int_value);
    }

    if (HippoSettings_get_int(api, ext, ID_VOLUME_RAMPING, &int_value) == HippoSettingsError_Ok) {
        data->mod->set_render_param(openmpt::module::RENDER_VOLUMERAMPING_STRENGTH, int_value);
    }

    if (HippoSettings_get_int(api, ext, ID_INTERPOLATION_RANGE, &int_value) == HippoSettingsError_Ok) {
        data->mod->set_render_param(openmpt::module::RENDER_INTERPOLATIONFILTER_LENGTH, int_value);
    }

    if (HippoSettings_get_string(api, ext, ID_AMIGA_RESAMPLER_FILTER, &str) == HippoSettingsError_Ok) {
        data->mod->ctl_set_text("render.resampler.emulate_amiga_type", str);
    }

    if (HippoSettings_get_bool(api, ext, ID_USE_AMIGA_RESAMPLER_AMIGA_MODS, &bool_value) == HippoSettingsError_Ok) {
        data->mod->ctl_set_boolean("render.resampler.emulate_amiga", bool_value);
    }

    if (HippoSettings_get_float(api, ext, ID_TEMPO_FACTOR, &float_value) == HippoSettingsError_Ok) {
        data->mod->ctl_set_floatingpoint("play.tempo_factor", float_value);
    }

    if (HippoSettings_get_float(api, ext, ID_PITCH_FACTOR, &float_value) == HippoSettingsError_Ok) {
        data->mod->ctl_set_floatingpoint("play.pitch_factor", float_value);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int openmpt_open(void* user_data, const char* filename, int subsong, const HippoSettingsAPI* settings) {
    uint64_t size = 0;
    struct OpenMptData* replayer_data = (struct OpenMptData*)user_data;

    HippoIoErrorCode res =
        g_io_api->read_file_to_memory(g_io_api->priv_data, filename, &replayer_data->song_data, &size);

    if (res < 0) {
        hp_error("Failed to load %s to memory", filename);
        return -1;
    }

    try {
        replayer_data->mod = new openmpt::module(replayer_data->song_data, size);
    } catch (...) {
        hp_error("Failed to open %s even if is as supported format", filename);
        return -1;
    }

    hp_info("Started to play %s (subsong %d)", filename, subsong);

    replayer_data->length = (float)replayer_data->mod->get_duration_seconds();
    replayer_data->mod->select_subsong(subsong);

    settings_apply(replayer_data, settings);

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int openmpt_close(void* user_data) {
    struct OpenMptData* replayer_data = (struct OpenMptData*)user_data;

    if (g_io_api) {
        g_io_api->free_file_to_memory(g_io_api->priv_data, replayer_data->song_data);
    }

    delete replayer_data->mod;
    delete replayer_data;

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static HippoReadInfo openmpt_read_data(void* user_data, void* dest, uint32_t max_output_bytes,
                                       uint32_t sample_rate) {
    struct OpenMptData* replayer_data = (struct OpenMptData*)user_data;

    const int samples_to_generate = hippo_min(512, max_output_bytes / 8);

    // support overringing the default sample rate
    if (replayer_data->sample_rate != 0) {
        sample_rate = replayer_data->sample_rate;
    }

    uint8_t channel_count = 2;
    uint16_t gen_count = 0;

    switch (replayer_data->channels) {
        default:
        case Channels::Stereo:
        case Channels::Default: {
            gen_count = (uint16_t)replayer_data->mod->read_interleaved_stereo(sample_rate, samples_to_generate, (float*)dest);
            break;
        }

        case Channels::Mono: {
            gen_count = (uint16_t)replayer_data->mod->read(sample_rate, samples_to_generate, (float*)dest);
            channel_count = 1;
            break;
        }

        case Channels::Quad: {
            gen_count = (uint16_t)replayer_data->mod->read_interleaved_quad(sample_rate, samples_to_generate, (float*)dest);
            channel_count = 4;
            break;
        }
    }

    // Send current positions back to frontend if we have some more data
    /*
    if (gen_count > 0) {
        flatbuffers::FlatBufferBuilder builder(1024);
        builder.Finish(CreateHippoMessageDirect(
            builder, MessageType_current_position,
            CreateHippoCurrentPosition(builder, replayer_data->mod->get_position_seconds(),
                                       replayer_data->mod->get_current_pattern(), replayer_data->mod->get_current_row(),
                                       replayer_data->mod->get_current_speed(), replayer_data->length)
                .Union()));
        HippoMessageAPI_send(replayer_data->message_api, builder.GetBufferPointer(), builder.GetSize());
    }
    */

    return HippoReadInfo{sample_rate, gen_count, channel_count, HippoOutputType_f32};
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int openmpt_seek(void* user_data, int ms) {
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char* filename_from_path(const char* path) {
    for (size_t i = strlen(path) - 1; i > 0; i--) {
        if (path[i] == '/') {
            return &path[i + 1];
        }
    }

    return path;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int openmpt_metadata(const char* filename, const HippoServiceAPI* service_api) {
    void* data = 0;
    uint64_t size = 0;

    const HippoIoAPI* io_api = HippoServiceAPI_get_io_api(service_api, HIPPO_FILE_API_VERSION);
    const HippoMetadataAPI* metadata_api = HippoServiceAPI_get_metadata_api(service_api, HIPPO_METADATA_API_VERSION);

    HippoIoErrorCode res = HippoIo_read_file_to_memory(io_api, filename, &data, &size);

    if (res < 0) {
        return res;
    }

    openmpt::module* mod = nullptr;

    try {
        mod = new openmpt::module(data, size);
    } catch (...) {
        hp_error("Failed to open %s even if is as supported format", filename);
        return -1;
    }

    auto index = HippoMetadata_create_url(metadata_api, filename);
    char title[512] = {0};

    const auto& mod_title = mod->get_metadata("title");

    if (mod_title != "") {
        strcpy(title, mod_title.c_str());
    } else {
        const char* file_title = filename_from_path(filename);
        strcpy(title, file_title);
    }

    hp_info("Updating meta data for %s", filename);

    HippoMetadata_set_tag(metadata_api, index, HippoMetadata_TitleTag, title);
    HippoMetadata_set_tag(metadata_api, index, HippoMetadata_SongTypeTag, mod->get_metadata("type_long").c_str());
    HippoMetadata_set_tag(metadata_api, index, HippoMetadata_AuthoringToolTag, mod->get_metadata("tracker").c_str());
    HippoMetadata_set_tag(metadata_api, index, HippoMetadata_ArtistTag, mod->get_metadata("artist").c_str());
    HippoMetadata_set_tag(metadata_api, index, HippoMetadata_DateTag, mod->get_metadata("date").c_str());
    HippoMetadata_set_tag(metadata_api, index, HippoMetadata_MessageTag, mod->get_metadata("message").c_str());
    HippoMetadata_set_tag_f64(metadata_api, index, HippoMetadata_LengthTag, mod->get_duration_seconds());

    for (const auto& sample : mod->get_sample_names()) {
        HippoMetadata_add_sample(metadata_api, index, sample.c_str());
    }

    for (const auto& instrument : mod->get_instrument_names()) {
        HippoMetadata_add_instrument(metadata_api, index, instrument.c_str());
    }

    const int subsong_count = mod->get_num_subsongs();

    if (subsong_count > 1) {
        int i = 0;
        for (const auto& name : mod->get_subsong_names()) {
            char subsong_name[1024] = {0};

            if (name != "") {
                sprintf(subsong_name, "%s - %s (%d/%d)", title, name.c_str(), i + 1, subsong_count);
            } else {
                sprintf(subsong_name, "%s (%d/%d)", title, i + 1, subsong_count);
            }

            mod->select_subsong(i);
            HippoMetadata_add_subsong(metadata_api, index, i, subsong_name, (float)mod->get_duration_seconds());

            ++i;
        }
    }

    // Make sure to free the buffer before we leave
    HippoIo_free_file_to_memory(io_api, data);

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void openmpt_event(void* user_data, const unsigned char* data, int len) {
    (void)len;
    (void)user_data;
    (void)data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void openmpt_settings_updated(void* user_data, const HippoSettingsAPI* settings) {
    settings_apply((OpenMptData*)user_data, settings);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void openmpt_static_init(struct HippoLogAPI* log, const HippoServiceAPI* service_api) {
    g_hp_log = log;

    g_settings_api = HippoServiceAPI_get_settings_api(service_api, HIPPO_SETTINGS_API_VERSION);

    if (HippoSettings_register_settings(g_settings_api, PLUGIN_NAME, s_settings) != HippoSettingsError_Ok) {
        // hp_error("Unable to register settings, error: %s", HippoSettings_get_last_error(api));
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static HippoPlaybackPlugin s_openmpt_plugin = {
    HIPPO_PLAYBACK_PLUGIN_API_VERSION,
    PLUGIN_NAME,
    "0.0.2",
    "libopenmpt 0.5.4",
    openmpt_probe_can_play,
    openmpt_supported_extensions,
    openmpt_create,
    openmpt_destroy,
    openmpt_event,
    openmpt_open,
    openmpt_close,
    openmpt_read_data,
    openmpt_seek,
    openmpt_metadata,
    openmpt_static_init,
    openmpt_settings_updated,
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

extern "C" HIPPO_EXPORT HippoPlaybackPlugin* hippo_playback_plugin() {
    return &s_openmpt_plugin;
}
